3. Проектирование и дизайн внешнего интерфейса.

В предыдущих заданиях мы разработали модель данных.
Это хорошее начальное приближение, если в будущем будет необходимо
мы всегда сможем вернуться к модели данных и улучшить ее.

А теперь пришла пора приступать к разработке алгоритма.

Напомним, что в нашей задаче под алгоритмом понимается
процесс расчёта стоимости страхового полиса.

Итак, приступим к работе над проектированием и дизайном решения (алгоритма).

С чего же нам следует начать?

Может сразу приступим к написанию кода?

Может сначала напишем acceptance тесты,
а потом будем писать код как в TDD?

Возьмём лист бумаги и нарисуем блок-схему алгоритма?


Прежде чем читать дальше подумайте как бы вы поступили,
попробуйте обосновать ваш выбор приведя конкретные аргументы.


Хм ... нам кажется, что правильнее всего начать вот с чего.

Давайте встанем (виртуально) на сторону клиента нашего будущего
решения. Под клиентом тут понимается человек или другая программа,
которая будет пользоваться нашим решением (расчётом стоимости
страхового полиса).

Любое ИТ решение состоит из множества частей, которые друг с другом
взаимодействуют! Для разработки хорошего решения нужно сделать так,
чтобы вашим решением было удобно пользоваться. А для этого нужно
встать на сторону клиента вашего кода и понять как клиент будет
взаимодействовать с вашим будущим решением.

Для того чтобы понять как клиент будет взаимодействовать с
вашим будущим решением нужно ответить на следующие вопросы:
- какие входные данные клиент будет предоставлять нашему решению на вход?
- какой результат клиент ожидает получить от нашего решения?
- как буквально клиент будет вызывать наше решение (API)?


Клиент -> наше решение.

Клиент вызывает наше решение.

Клиент при вызове передаёт входные данные.

Клиент ожидает получить результат (в каком виде).

Как конкретно клиент будет вызывать наше решение,
как будет происходить взаимодействие
(интерфейс, вызов метода, и так далее)?


Очень важно сделать так, чтобы клиенту было реально удобно пользоваться
нашим решением. Для клиента наше решение должно быть простым в
использовании, удобным, понятным. Только тогда наше решение
можно будет признать качественным.

Один из главных принципов разработки: решение должно скрывать
от клиента все сложности реализации и предоставлять простой и
понятный интерфейс взаимодействия с ним.


Как клиент должен видеть наше решение?
Что говорится об этом в самом задании?

Прежде чем читать дальше попробуйте найти ответы на
эти вопросы в тексте задания.


Preferred invocation of the functionality but may be changed if needed:
PremiumCalculator#calculate(Policy policy);


Из этого описания видно, что нам предлагают создать класс или
интерфейс PremiumCalculator с методом calculate в который
как параметр передаётся объект Policy.

Объект/класс Policy мы уже создали при разработке модели данных.
Он относится к доменной модели нашей задачи.

PremiumCalculator#calculate(Policy policy); - что остаётся не
ясным в вызове этого метода?


При вызове этого метода не ясным (пропущенным) остаётся тип
возвращаемого значения.

Должен ли этот метод что-то возвращать?

И если да то что конкретно?


Да должен, премию (стоимость) страхового полиса.

Премия страхового полиса это сумма ДЕНЕГ, которую должен
заплатить клиент при покупке полиса страхования.

Значит речь идёт о деньгах!

Как представить деньги в Java?

Мы уже знаем ответ на этот вопрос - класс BigDecimal!

Значит полная сигнатура метода будет выглядеть так:

BigDecimal PremiumCalculator#calculate(Policy policy);

В этом случае клиенту нужно будет создать объект Policy,
заполнить его данными и передать его в метод calculate
класса PremiumCalculator, метод calculate на основе полученного
полиса рассчитает премию (стоимость полиса) и вернёт ее клиенту
в качестве результата в виде BigDecimal.


Ваше задание: создайте класс PremiumCalculator с методом

BigDecimal calculate(Policy policy) {
    return BigDecimal.ZERO;
}

пусть метод возвращает BigDecimal.ZERO или любое другое значение,
это сделано для того, чтобы код программы компилировался, и мы могли
продолжить разработку.