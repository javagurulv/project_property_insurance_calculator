После внесения изменений класс PremiumCalculator
сократился с почти 90 строк кода до 25!

Взгляните, а чего мы добились этими изменениями?

Главное нам удалось отделить от общего кода алгоритмы
расчёта премии для каждого риска в отдельности. Теперь
эти алгоритмы находятся в разных классах! Это очень классно!

Почему?

Если вдруг любой из алгоритмов расчёта премии для риска поменяется
(бизнес изменит формулу расчёта), то для внесения изменений в программу
нам придётся менять не общий класс PremiumCalculator, а класс в котором
содержится нужный нам алгоритм расчёта премии для конкретного риска.

Мы минимизируем влияние наших изменений на все оставшиеся классы!
Если мы не меняем код других классов, мы не можем внести в них ошибку!

Теперь наша реализация алгоритма расчёта премии полиса состоит из
главного класса PremiumCalculator и отдельных классов для расчёта
премии каждого риска. Архитектура нашего решения поменялась.

Что нужно будет сделать если бизнес захочет добавить новый риск?

Для добавления нового риска нам нужно создать отдельный класс
(аля NewRiskCalculator), реализовать в нём алгоритм расчёта
премии нового риска и добавить его в класс PremiumCalculator.

Изменения в классе PremiumCalculator будут минимальны!

Алгоритмы расчёта премии каждого риска реализованы физически
отдельно друг от друга (они находятся в разных классах). Это
даёт нам возможность отдельно менять их друг от друга. Это
так же упрощает тестирование! Теперь мы запросто можем написать
тесты на каждый расчёт премии риска в отдельности и убедиться
что каждый из них работает правильно!

Это уже огромные достижения!

Но можно пойти еще дальше и сделать так, чтобы при добавлении
нового риска не нужно было вносить изменения в класс PremiumCalculator
вообще. Но об этом расскажем в других заданиях!
